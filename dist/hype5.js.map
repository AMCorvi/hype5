{"version":3,"sources":["hype5.js"],"names":["runCasper","type","filter","returnValue","data","Promise","resolve","reject","puts","err","stdout","stderr","console","log","then","trackData","top","crawlFunc","options","output","find","val","SyntaxError","getData","x","catch","noremixes","remixes"],"mappings":";;;;;;;AAAA;;AACA;;;;AAEA,IAAIA;AAAA,oEAAY,iBAAeC,IAAf,EAAqBC,MAArB;AAAA;AAAA;AAAA;AAAA;AAAA;AACf;AACIC,iBAFW;;AAIf;;AACMC,UALS,GAKF,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AAC7C;AACA,gBAASC,IAAT,CAAcC,GAAd,EAAmBC,MAAnB,EAA2BC,MAA3B,EAAmC;AAClC,YAAIF,GAAJ,EAAS;AACRF,gBAAOE,GAAP;AACA,SAFD,MAEO,IAAIE,MAAJ,EAAY;AAClBJ,gBAAOI,MAAP;AACA,SAFM,MAEA;AACNL,iBAAQI,MAAR;AACA;AACD;;AAED,WAAIT,QAAQC,MAAZ,EAAoB;AACnB,sFACoDD,IADpD,sBACyEC,MADzE,EAECM,IAFD;AAIA,QALD,MAKO,IAAIP,IAAJ,EAAU;AAChB,sFAAwDA,IAAxD,QAAiEO,IAAjE;AACA,QAFM,MAEA,IAAI,CAACP,IAAL,EAAW;AACRW,gBAAQC,GAAR,CAAY,mBAAZ;AACT,iCAAK,uCAAL,EAA8CL,IAA9C;AACA;AACD,OAvBY,CALE;;AA8Bf;;AA9Be;AAAA,aA+BTJ,KAAKU,IAAL,CAAU;AAAA,cAAcX,cAAcY,SAA5B;AAAA,OAAV,CA/BS;;AAAA;AAAA,uCAiCRZ,WAjCQ;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAAZ;;AAAA;AAAA;AAAA;AAAA,GAAJ;;AAoCO,IAAMa;AAAA,qEAAM,kBAAOf,IAAP;AAAA,MAAagB,SAAb,uEAAyBjB,SAAzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAClB;AACMkB,aAFY,GAEF,CAAC,SAAD,EAAY,QAAZ,CAFE;AAGlB;;AACIC,YAJc;;AAMlB;;AANkB;;AAAA,WAQblB,IARa;AAAA;AAAA;AAAA;;AAAA,UASXiB,QAAQE,IAAR,CAAa;AAAA,cAAOC,QAAQpB,IAAf;AAAA,OAAb,CATW;AAAA;AAAA;AAAA;;AAAA,YAUT,IAAIqB,WAAJ,gEACwDrB,IADxD,sDAC6GiB,OAD7G,SAEL,UAFK,EAGL,EAHK,CAVS;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAqBZK,aArBY,GAqBF,SAAVA,OAAU,GAAM;AACrB,cAAO,IAAIlB,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACvC,YAAI;AACH,aAAMiB,IAAIvB,OAAOgB,UAAUhB,IAAV,CAAP,GAAyBgB,WAAnC;AACAX,iBAAQkB,CAAR;AACA,SAHD,CAGE,OAAOf,GAAP,EAAY;AACbF,gBAAOE,GAAP;AACA;AACD,QAPM,CAAP;AAQA,OA9BiB;;AAAA;AAAA,aAgCZc,UACJT,IADI,CACC,gBAAQ;AACbK,gBAASf,IAAT;AACA,OAHI,EAIJqB,KAJI,CAIE,eAAO;AACb,aAAMhB,GAAN;AACA,OANI,CAhCY;;AAAA;AAAA,wCAwCXU,MAxCW;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAAN;;AAAA;AAAA;AAAA;AAAA,GAAN;;AA2CA,IAAMO;AAAA,qEAAY,kBAAOzB,IAAP;AAAA,MAAagB,SAAb,uEAAyBjB,SAAzB;AAAA;AAAA;AAAA;AAAA;AAAA;AACxB;AACMkB,aAFkB,GAER,CAAC,SAAD,EAAY,QAAZ,CAFQ;AAGxB;;AACIC,YAJoB;;AAMxB;;AANwB;;AAAA,UAQlBD,QAAQE,IAAR,CAAa;AAAA,cAAOC,QAAQpB,IAAf;AAAA,OAAb,CARkB;AAAA;AAAA;AAAA;;AAAA,YAShB,IAAIqB,WAAJ,gEACwDrB,IADxD,sDAC6GiB,OAD7G,SAEL,UAFK,EAGL,EAHK,CATgB;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAmBlBK,aAnBkB,GAmBR,SAAVA,OAAU,GAAM;AACrB,cAAO,IAAIlB,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACvC,YAAI;AACH,aAAMiB,IAAIP,UAAUhB,IAAV,EAAgB,SAAhB,CAAV;AACAK,iBAAQkB,CAAR;AACA,SAHD,CAGE,OAAOf,GAAP,EAAY;AACbF,gBAAOE,GAAP;AACA;AACD,QAPM,CAAP;AAQA,OA5BuB;;AAAA;AAAA,aA8BlBc,UACJT,IADI,CACC,gBAAQ;AACbK,gBAASf,IAAT;AACA,OAHI,EAIJqB,KAJI,CAIE,eAAO;AACb,aAAMhB,GAAN;AACA,OANI,CA9BkB;;AAAA;AAAA,wCAsCjBU,MAtCiB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAAZ;;AAAA;AAAA;AAAA;AAAA,GAAN;;AAyCA,IAAMQ;AAAA,qEAAU,kBAAO1B,IAAP;AAAA,MAAagB,SAAb,uEAAyBjB,SAAzB;AAAA;AAAA;AAAA;AAAA;AAAA;AACtB;AACMkB,aAFgB,GAEN,CAAC,SAAD,EAAY,QAAZ,CAFM;AAGtB;;AACIC,YAJkB;;AAMtB;;AANsB;;AAAA,UAQhBD,QAAQE,IAAR,CAAa;AAAA,cAAOC,QAAQpB,IAAf;AAAA,OAAb,CARgB;AAAA;AAAA;AAAA;;AAAA,YASd,IAAIqB,WAAJ,gEACwDrB,IADxD,sDAC6GiB,OAD7G,SAEL,UAFK,EAGL,EAHK,CATc;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAmBhBK,aAnBgB,GAmBN,SAAVA,OAAU,GAAM;AACrB,cAAO,IAAIlB,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACvC,YAAI;AACH,aAAMiB,IAAIP,UAAUhB,IAAV,EAAgB,OAAhB,CAAV;AACAK,iBAAQkB,CAAR;AACA,SAHD,CAGE,OAAOf,GAAP,EAAY;AACbF,gBAAOE,GAAP;AACA;AACD,QAPM,CAAP;AAQA,OA5BqB;;AAAA;AAAA,aA8BhBc,UACJT,IADI,CACC,gBAAQ;AACbK,gBAASf,IAAT;AACA,OAHI,EAIJqB,KAJI,CAIE,eAAO;AACb,aAAMhB,GAAN;AACA,OANI,CA9BgB;;AAAA;AAAA,wCAsCfU,MAtCe;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAAV;;AAAA;AAAA;AAAA;AAAA,GAAN","file":"hype5.js","sourcesContent":["import \"babel-polyfill\";\nimport { exec } from \"child_process\";\n\nlet runCasper = async function(type, filter) {\n\t// Variable to assign return data\n\tlet returnValue;\n\n\t// Handle child process call asyncronously\n\tconst data = new Promise((resolve, reject) => {\n\t\t// Call back function for 'exec' to handle respone from exec() call\n\t\tfunction puts(err, stdout, stderr) {\n\t\t\tif (err) {\n\t\t\t\treject(err);\n\t\t\t} else if (stderr) {\n\t\t\t\treject(stderr);\n\t\t\t} else {\n\t\t\t\tresolve(stdout);\n\t\t\t}\n\t\t}\n\n\t\tif (type && filter) {\n\t\t\texec(\n\t\t\t\t`casperjs --verbose ./dist/crawler.js --hypeType=${type} --hypeFilter=${filter}`,\n\t\t\t\tputs\n\t\t\t);\n\t\t} else if (type) {\n\t\t\texec(`casperjs --verbose ./dist/crawler.js --hypeType=${type} `, puts);\n\t\t} else if (!type) {\n            console.log(\"no filter no type\")\n\t\t\texec(\"casperjs --verbose ./dist/crawler.js \", puts);\n\t\t}\n\t});\n\n\t// pause for data and assign to returnValue variable\n\tawait data.then(trackData => (returnValue = trackData));\n\n\treturn returnValue;\n};\n\nexport const top = async (type, crawlFunc = runCasper) => {\n\t// list of options that are actually valid\n\tconst options = [\"popular\", \"latest\"];\n\t// Value assigned to and return by function\n\tlet output;\n\n\t// Compare filter parameter with list of possible valid filters\n\ttry {\n\t\tif (type) {\n\t\t\tif (!options.find(val => val === type)) {\n\t\t\t\tthrow new SyntaxError(\n\t\t\t\t\t` \\n\\n \\t Call of function 'remixes' made with invalid arg ${type}.\\n\\t Insert valid filter argument. \\n\\t e.g. ${options}\\n`,\n\t\t\t\t\t\"index.js\",\n\t\t\t\t\t89\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t} catch (e) {\n\t\tthrow e;\n\t}\n\n\tconst getData = () => {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tconst x = type ? crawlFunc(type) : crawlFunc();\n\t\t\t\tresolve(x);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\tawait getData()\n\t\t.then(data => {\n\t\t\toutput = data;\n\t\t})\n\t\t.catch(err => {\n\t\t\tthrow err;\n\t\t});\n\n\treturn output;\n};\n\nexport const noremixes = async (type, crawlFunc = runCasper) => {\n\t// list of options that are actually valid\n\tconst options = [\"popular\", \"latest\"];\n\t// Value assigned to and return by function\n\tlet output;\n\n\t// Compare filter parameter with list of possible valid filters\n\ttry {\n\t\tif (!options.find(val => val === type)) {\n\t\t\tthrow new SyntaxError(\n\t\t\t\t` \\n\\n \\t Call of function 'remixes' made with invalid arg ${type}.\\n\\t Insert valid filter argument. \\n\\t e.g. ${options}\\n`,\n\t\t\t\t\"index.js\",\n\t\t\t\t89\n\t\t\t);\n\t\t}\n\t} catch (e) {\n\t\tthrow e;\n\t}\n\n\tconst getData = () => {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tconst x = crawlFunc(type, \"noremix\");\n\t\t\t\tresolve(x);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\tawait getData()\n\t\t.then(data => {\n\t\t\toutput = data;\n\t\t})\n\t\t.catch(err => {\n\t\t\tthrow err;\n\t\t});\n\n\treturn output;\n};\n\nexport const remixes = async (type, crawlFunc = runCasper) => {\n\t// list of options that are actually valid\n\tconst options = [\"popular\", \"latest\"];\n\t// Value assigned to and return by function\n\tlet output;\n\n\t// Compare filter parameter with list of possible valid filters\n\ttry {\n\t\tif (!options.find(val => val === type)) {\n\t\t\tthrow new SyntaxError(\n\t\t\t\t` \\n\\n \\t Call of function 'remixes' made with invalid arg ${type}.\\n\\t Insert valid filter argument. \\n\\t e.g. ${options}\\n`,\n\t\t\t\t\"index.js\",\n\t\t\t\t89\n\t\t\t);\n\t\t}\n\t} catch (e) {\n\t\tthrow e;\n\t}\n\n\tconst getData = () => {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tconst x = crawlFunc(type, \"remix\");\n\t\t\t\tresolve(x);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\tawait getData()\n\t\t.then(data => {\n\t\t\toutput = data;\n\t\t})\n\t\t.catch(err => {\n\t\t\tthrow err;\n\t\t});\n\n\treturn output;\n};\n"]}